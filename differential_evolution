import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import differential_evolution

class PIDController:
    def __init__(self, Kp, Ki, Kd, max_rate):
        self.Kp = np.float64(Kp)
        self.Ki = np.float64(Ki)
        self.Kd = np.float64(Kd)
        self.max_rate = np.float64(max_rate)
        self.integral = np.float64(0)
        self.last_error = np.float64(0)
        self.last_output = np.float64(0)
        self.error_log = []

    def update(self, error, dt, current_time):
        self.integral += error * dt
        derivative = (error - self.last_error) / dt if dt > 0 else 0
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        rate_change = (output - self.last_output) / dt if dt > 0 else 0
        if abs(rate_change) > self.max_rate:
            output = self.last_output + np.sign(rate_change) * self.max_rate * dt
        self.last_output = output
        self.last_error = error
        return output
def complex_trajectory(t, A, B, f, phase_shift, t_max):
    if t < t_max / 3:
        return A * (t / (t_max / 3)) * np.sin(2 * np.pi * f * t + phase_shift)
    elif t < 2 * t_max / 3:
        return A * np.sin(2 * np.pi * f * t + phase_shift)
    else:
        return A * ((t_max - t) / (t_max / 3)) * np.sin(2 * np.pi * f * t + phase_shift)

def model(t, y, pid, A, B, f, phase_shift, t_max, dt):
    x, x_dot = y
    y_d = complex_trajectory(t, A, B, f, phase_shift, t_max)
    error = y_d - x
    u_pid = pid.update(error, dt, t)
    dxdt = x_dot
    dx_dot_dt = (-k * x - c * x_dot + u_pid) / m
    return [dxdt, dx_dot_dt]

def objective(params):
    Kp, Ki, Kd = params
    pid = PIDController(Kp, Ki, Kd, max_rate)
    sol = solve_ivp(lambda t, y: model(t, y, pid, A, B, f, phase_shift, t_max, dt), t_span, y0, t_eval=t_eval)
    errors = [complex_trajectory(t, A, B, f, phase_shift, t_max) - y[0] for t, y in zip(sol.t, sol.y.T)]
    sse = np.sum(np.square(errors))
    return sse

# System and PID parameters
m, c, k = 1.0, 0.5, 20.0
A, B, f, phase_shift, t_max = 1.0, 0, 0.5, 0, 10
t_span = [0, t_max]
t_eval = np.linspace(t_span[0], t_span[1], 10000)
dt = t_eval[1] - t_eval[0]
y0 = [0, 0]
max_rate = 10000

bounds = [(100, 1000), (0, 100), (0, 100)]

result = differential_evolution(objective, bounds, maxiter=100, popsize=10, strategy='best1bin')

print("Best parameters: Kp={:.2f}, Ki={:.2f}, Kd={:.2f}".format(result.x[0], result.x[1], result.x[2]))
print("Best SSE: {:.2f}".format(result.fun))

# Visualizing the best solution
pid_best = PIDController(*result.x, max_rate)
sol_best = solve_ivp(lambda t, y: model(t, y, pid_best, A, B, f, phase_shift, t_max, dt), t_span, y0, t_eval=t_eval)
errors_best = [complex_trajectory(t, A, B, f, phase_shift, t_max) - y[0] for t, y in zip(sol_best.t, sol_best.y.T)]

plt.figure(figsize=(10, 5))
plt.plot(t_eval, errors_best, label='Best PID')
plt.xlabel('Time (seconds)')
plt.ylabel('Error')
plt.title('Error Comparison')
plt.legend()
plt.grid(True)
plt.show()
